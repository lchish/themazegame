/*Some of this code was not written by me - 
  Got off website - Did not have any licence */

#include <cstdio>
#include <cstdlib>
#include <list>
#include <ctime>
#include <cstring>
#include <string>
#include <vector>
#include <set>
#include <map>
#include <iostream>

#include "maze.h"
#include "defs.h"


using std::string;
using std::vector;



int temp_maze[N_ROWS][N_COLUMNS][4]; // for some glue code, the maze generated by this function is quite a bit different to the maze we use in the game.




/*FOLLOWING CODE NOT WRITTEN BY US */

typedef std::set<int>        Group;
typedef std::map<int, Group> GroupIdToGroup;

/*A Tile class. */
class Room
{
public:
  Room(int id, int row, int column);

  void  visit(int depth, Group &visited, Room *caller);
  void  deadEndFound(int depth, Room *room);
  Room  *getMaxRoom();

  bool hasNorth();
  bool hasSouth();
  bool hasEast();
  bool hasWest();

  void setNorth(Room *north);
  void setSouth(Room *south);
  void setEast (Room *east);
  void setWest (Room *west);

  void setGroupID(int id);
  int  getGroupID();

public:
  const int mID;
  const int mRow;
  const int mColumn;

private:
  int mGroupID;

  Room *mNorth;
  Room *mSouth;
  Room *mEast;
  Room *mWest;

  Room *mMaxRoom;
  int   mMaxDepth;
};

typedef vector<Room *>  RoomRow;
typedef vector<RoomRow> Rooms;

class Wall
{
public:
  Wall(Room *first, Room *second);
  Room *getFirst();
  Room *getSecond();

private:
  Room *mFirst;
  Room *mSecond;
  bool  mPresent;
};

typedef vector<Wall *> Walls;

template <typename T>
class Cleaner
{
public:
  Cleaner();
  ~Cleaner();
  void add(T *ptr);

private:
  Cleaner(const Cleaner &);
  Cleaner &operator=(const Cleaner &);

private:
  vector<T *> mList;
};

template <typename T>
Cleaner<T>::Cleaner()
{
}

template <typename T>
Cleaner<T>::~Cleaner()
{
  for(int n = mList.size(), i = 0; i < n; i ++)
    {
      delete mList[i];
      mList[i] = NULL;
    }

  mList.clear();
}

template <typename T>
void Cleaner<T>::add(T *ptr)
{
  mList.push_back(ptr);
}

/*****************************************************************
 * Local Function Prototypes
 *****************************************************************/

static void seedRandom();

static void init(
		 int           rows,
		 int           columns,
		 Rooms         &rooms,
		 Walls         &walls,
		 Cleaner<Room> &roomCleaner,
		 Cleaner<Wall> &wallCleaner
		 );

/*****************************************************************
 * Local Type Definitions
 *****************************************************************/

// --------------
// Room
// --------------

Room::Room(int id, int row, int column) :
  mID(id), mRow(row), mColumn(column), mGroupID(0), 
  mNorth(0), mSouth(0), mEast(0), mWest(0), mMaxRoom(0), mMaxDepth(0)
{
}

void Room::visit(int depth, Group &visited, Room *caller)
{
  bool isDeadEnd = true;

  visited.insert(mID);

  if(mNorth && visited.find(mNorth->mID) == visited.end())
    {
      isDeadEnd = false;
      mNorth->visit(depth + 1, visited, caller);
    }

  if(mSouth && visited.find(mSouth->mID) == visited.end())
    {
      isDeadEnd = false;
      mSouth->visit(depth + 1, visited, caller);
    }

  if(mWest && visited.find(mWest->mID) == visited.end())
    {
      isDeadEnd = false;
      mWest->visit(depth + 1, visited, caller);
    }

  if(mEast && visited.find(mEast->mID) == visited.end())
    {
      isDeadEnd = false;
      mEast->visit(depth + 1, visited, caller);
    }

  if(isDeadEnd)
    {
      caller->deadEndFound(depth, this);
    }
}

void Room::deadEndFound(int depth, Room *room)
{
  if(depth > mMaxDepth)
    {
      mMaxDepth = depth;
      mMaxRoom  = room;
    }
}

Room *Room::getMaxRoom()
{
  return(mMaxRoom);
}

bool Room::hasNorth() { return(mNorth != NULL); }
bool Room::hasSouth() { return(mSouth != NULL); }
bool Room::hasEast()  { return(mEast  != NULL); }
bool Room::hasWest()  { return(mWest  != NULL); }

void Room::setNorth(Room *ptr) { mNorth = ptr; }
void Room::setSouth(Room *ptr) { mSouth = ptr; }
void Room::setEast (Room *ptr) { mEast  = ptr; }
void Room::setWest (Room *ptr) { mWest  = ptr; }

void Room::setGroupID(int id) { mGroupID = id;    }
int  Room::getGroupID()       { return(mGroupID); }

// --------------
// Wall
// --------------

Wall::Wall(Room *first, Room *second) :
  mFirst(first), mSecond(second), mPresent(true)
{
}

Room *Wall::getFirst()  { return(mFirst);  }
Room *Wall::getSecond() { return(mSecond); }

/*****************************************************************
 * Local Functions
 *****************************************************************/

static void seedRandom()
{
  srand(time(NULL));
}




static void init(
		 int           rows,
		 int           columns,
		 Rooms         &rooms,
		 Walls         &walls,
		 Cleaner<Room> &roomCleaner,
		 Cleaner<Wall> &wallCleaner
		 )
{
  int i  = 0;
  int j  = 0;
  int id = 0;

  for(i = 0; i < rows; i ++)
    {
      RoomRow row;

      for(int j = 0; j < columns; j ++, id ++)
	{
	  Room *roomPtr = new Room(id, i, j);

	  row.push_back(roomPtr);
	  roomCleaner.add(roomPtr);
	}

      rooms.push_back(row);
    }

  for(i = 0; i < rows; i ++)
    {
      for(j = 1; j < columns; j ++)
	{
	  Room *first   = rooms[i][j - 1];
	  Room *second  = rooms[i][j];
	  Wall *wallPtr = new Wall(first, second);

	  walls.push_back(wallPtr);
	  wallCleaner.add(wallPtr);
	}
    }

  for(i = 1; i < rows; i ++)
    {
      for(j = 0; j < columns; j ++)
	{
	  Room *first   = rooms[i - 1][j];
	  Room *second  = rooms[i][j];
	  Wall *wallPtr = new Wall(first, second);

	  walls.push_back(wallPtr);
	  wallCleaner.add(wallPtr);
	}
    }
}



void gen_maze()
{
  int rows              = N_ROWS;
  int columns           = N_COLUMNS;
 

  string errMsg         = "";


  Rooms rooms;
  Walls walls;

  Cleaner<Room> roomCleaner;
  Cleaner<Wall> wallCleaner;

  init(rows, columns, rooms, walls, roomCleaner, wallCleaner);

  int nWalls = walls.size();

  // ------------------------------------------------
  // Shuffle the walls
  // ------------------------------------------------

  seedRandom();

  int i = 0;
  int j = 0;

  for(i = 0; i < nWalls; i ++)
    {
      int idx1 = 0;
      int idx2 = 0;

      do {

	int value1 = rand();
	int value2 = rand();

	if(value1 < 0) value1 = -value1;
	if(value2 < 0) value2 = -value2;

	idx1 = value1 % nWalls;
	idx2 = value2 % nWalls;

      }  while(idx1 == idx2);

      Wall *ptr   = walls[idx1];
      walls[idx1] = walls[idx2];
      walls[idx2] = ptr;
    }

  // ---------------------------------------------
  // Put each room initially into its own group
  // ---------------------------------------------

  GroupIdToGroup gMap;

  for(i = 0; i < rows; i ++)
    {
      for(j = 0; j < columns; j ++)
	{
	  Room *r = rooms[i][j];

	  Group theGroup;

	  theGroup.insert(r->mID);

	  gMap[r->mID] = theGroup;
	  r->setGroupID(r->mID);
	}
    }

  // ------------------------------------------------
  // Now start knocking down walls ...
  // ------------------------------------------------

  for(i = 0; i < nWalls; i ++)
    {
  

      Room *first  = walls[i]->getFirst();
      Room *second = walls[i]->getSecond();

      // Are these two rooms already reachable
      // from one another?

      if(first->getGroupID() != second->getGroupID())
	{
	  // Not yet reachable so correct that ...

	  if(first->mColumn == second->mColumn)
	    {
	      first->setNorth(second);
	      second->setSouth(first);
	    }
	  else
	    {
	      first->setEast(second);
	      second->setWest(first);
	    }

	  // Now, we need to put everyone from second's group
	  // into first's group

	  int sid        = second->getGroupID();
	  Group theGroup = gMap[sid];

	  Group::iterator gi;

	  for(gi = theGroup.begin(); gi != theGroup.end(); gi ++)
	    {
	      int roomID    = *gi;
	      int theRow    = roomID / columns;
	      int theColumn = roomID % columns;

	      Room *ptr = rooms[theRow][theColumn];
	      int gid   = first->getGroupID();

	      gMap[gid].insert(roomID);
	      ptr->setGroupID(gid);
	    }

	  gMap.erase(sid);
	}
    }

 
  /*ADDED CODE - Set our temp maze to what we generated*/
  for(int i = 0; i < N_ROWS; i++){
    for(int j = 0; j < N_COLUMNS; j++){
      if(rooms[j][i]->hasNorth()){
	temp_maze[i][j][NORTH] = 0;
      }
      if(rooms[j][i]->hasSouth()){
	temp_maze[i][j][SOUTH] = 0;
      }
      if(rooms[j][i]->hasEast()){
	temp_maze[i][j][EAST] = 0;
      }
      if(rooms[j][i]->hasWest()){
	temp_maze[i][j][WEST] = 0;
      }




    }
  }
}



//mazes are now 3d. Third dimension is walls.
Maze::Maze(){

  /*We Want our maze to have Walls everywhere initally*/
  for(int i = 0; i < N_ROWS; i++){
    for(int j = 0; j < N_COLUMNS; j++){

      temp_maze[i][j][NORTH] = 1;
      temp_maze[i][j][SOUTH] = 1;
      temp_maze[i][j][EAST] = 1;
      temp_maze[i][j][WEST] = 1;

      maze[i][j][NORTH] = 1;
      maze[i][j][EAST] = 1;
      maze[i][j][SOUTH] = 1;
      maze[i][j][WEST] = 1;

    }
  }

 
  /*Generate the maze - gets put into temp_maze*/
  gen_maze();

  /*Copy what was in temp_maze into our normal maze*/
  
  for(int i = 0; i < N_ROWS; i++){
    for(int j = 0; j < N_COLUMNS; j++){
      maze[i][j][NORTH] = temp_maze[i][j][NORTH];
      maze[i][j][SOUTH] = temp_maze[i][j][SOUTH];
      maze[i][j][EAST] = temp_maze[i][j][EAST];
      maze[i][j][WEST] = temp_maze[i][j][WEST];      
    }
  }  
  


}


int Maze::height(){
  return heightv;
}
int Maze::width(){
  return widthv;
}

int Maze::value_at(int i, int j, int k){
  return maze[i][j][k];
}
